#!/usr/bin/env python
# -*- coding:utf-8 -*-


# ############################################################################
#  license :
# ============================================================================
#
#  File :        SKAEXTRA.py
#
#  Project :     SKAEXTRA
#
# This file is part of Tango device class.
# 
# Tango is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tango is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tango.  If not, see <http://www.gnu.org/licenses/>.
# 
#
#  $Author :      cam$
#
#  $Revision :    $
#
#  $Date :        $
#
#  $HeadUrl :     $
# ============================================================================
#            This file is generated by POGO
#     (Program Obviously used to Generate tango Object)
# ############################################################################

__all__ = ["SKAEXTRA", "SKAEXTRAClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
from SKABASE import SKABASE, SKABASEClass
# Add additional import
#----- PROTECTED REGION ID(SKAEXTRA.additionnal_import) ENABLED START -----#
from lmc_api.servers.error_handling import exception_manager
from lmc_api.servers.alarms.formula_translator import FormulaTranslator
from lmc_api.library.utils import EnumEncoder, as_enum
from lmc_api.utils import  reset_alarms
from PyTango import DeviceProxy, AttrQuality, DbDatum, AttributeProxy, DevState, Database
import json
import math
import inspect
from datetime import datetime
from lmc_api.library.helpers import get_dp_attribute, get_dp_command
#----- PROTECTED REGION END -----#	//	SKAEXTRA.additionnal_import

# Device States Description
# ON : 
# OFF : 
# FAULT : 
# INIT : 
# RUNNING : 
# ALARM : 
# UNKNOWN : 
# MOVING : 


class SKAEXTRA (SKABASE):
    """A generic base device for SKA with EXTRA functionalities."""
    
    # -------- Add you global variables here --------------------------
    #----- PROTECTED REGION ID(SKAEXTRA.global_variables) ENABLED START -----#

    #----- PROTECTED REGION END -----#	//	SKAEXTRA.global_variables

    def __init__(self, cl, name):
        super(SKAEXTRA,self).__init__(cl,name)
        self.debug_stream("In __init__()")
        SKAEXTRA.init_device(self)
        #----- PROTECTED REGION ID(SKAEXTRA.__init__) ENABLED START -----#
        self.self_proxy = PyTango.DeviceProxy(self.get_name())

        elettra_proxy = DeviceProxy(self.ELETTRA_ALARM_DEVICE_ADDRESS)
        if self.CENTRAL_EVENTSTREAM_DEVICE_ADDRESS:
            self.event_proxy = DeviceProxy(self.CENTRAL_EVENTSTREAM_DEVICE_ADDRESS)
        reset_alarms(elettra_proxy, self.get_name())

        from threading import Thread
        from time import sleep

        def exported_hook():
            max_retries = 10
            retries = 0
            while retries < max_retries:
                try:
                    dp = DeviceProxy(self.get_name())
                    dp.ping()
                    dp.command_inout_asynch("on_exported_hook")
                    break
                except MemoryError:
                    # Something's wrong, do not call on_exported_hook
                    break
                except Exception as e:
                    # print "Waiting for device to be exported"
                    retries += 1
                    sleep(1)

        t = Thread(target=exported_hook)
        t.start()

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.__init__
        
    def delete_device(self):
        self.debug_stream("In delete_device()")
        #----- PROTECTED REGION ID(SKAEXTRA.delete_device) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_centralLoggerStatus_read = ''
        self.attr_elementLoggerStatus_read = ''
        self.attr_storageLoggerStatus_read = ''
        self.attr_fwdAttrInitStatus_read = ''
        self.attr_loggingLevelCentral_read = 0
        self.attr_loggingLevelElement_read = 0
        self.attr_loggingLevelStorage_read = 0
        self.attr_buildState_read = ""
        #----- PROTECTED REGION ID(SKAEXTRA.init_device) ENABLED START -----#
        with exception_manager(self):
            self.alarms_set = False
            self.DOMAIN = self.get_domain()
            self.ELETTRA_ALARM_DEVICE_ADDRESS = self.get_elettra_alarm_device_address()
            self.CENTRAL_ALARMSTREAM_DEVICE_ADDRESS = self.get_central_alarmstream_device_address()
            self.CENTRAL_EVENTSTREAM_DEVICE_ADDRESS = self.get_central_eventstream_device_address()

            self.device_id = self.get_name().split('/')[2]
            self.device_type = self.get_name().split('/')[1]
            self.register_set = set()
            self.metric_set = set()
            self.public_command_set = set()
            # start_poll_command, stop_polling_command, create_alarm, remove_alarm, get_device_alarms
            # keep an internal list of exposed metrics
            metric_list = self.get_device_metric_list()
            for metric in metric_list:
                self.metric_set.add(metric)

            # keep an internal list of exposed registers
            register_list = self.get_device_register_list()
            for register in register_list:
                self.register_set.add(register)

            # keep an internal list of exposed commands
            command_list = self.get_device_command_list()
            for command in command_list:
                self.public_command_set.add(command)

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        #----- PROTECTED REGION ID(SKAEXTRA.always_executed_hook) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.always_executed_hook

    # -------------------------------------------------------------------------
    #    SKAEXTRA read/write attribute methods
    # -------------------------------------------------------------------------
    
    def read_centralLoggerStatus(self, attr):
        self.debug_stream("In read_centralLoggerStatus()")
        #----- PROTECTED REGION ID(SKAEXTRA.centralLoggerStatus_read) ENABLED START -----#
        attr.set_value(self.attr_centralLoggerStatus_read)

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.centralLoggerStatus_read
        
    def read_elementLoggerStatus(self, attr):
        self.debug_stream("In read_elementLoggerStatus()")
        #----- PROTECTED REGION ID(SKAEXTRA.elementLoggerStatus_read) ENABLED START -----#
        attr.set_value(self.attr_elementLoggerStatus_read)

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.elementLoggerStatus_read
        
    def read_storageLoggerStatus(self, attr):
        self.debug_stream("In read_storageLoggerStatus()")
        #----- PROTECTED REGION ID(SKAEXTRA.storageLoggerStatus_read) ENABLED START -----#
        attr.set_value(self.attr_storageLoggerStatus_read)

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.storageLoggerStatus_read
        
    def read_fwdAttrInitStatus(self, attr):
        self.debug_stream("In read_fwdAttrInitStatus()")
        #----- PROTECTED REGION ID(SKAEXTRA.fwdAttrInitStatus_read) ENABLED START -----#
        attr.set_value(self.attr_fwdAttrInitStatus_read)

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.fwdAttrInitStatus_read
        
    
    
            
    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        #----- PROTECTED REGION ID(SKAEXTRA.read_attr_hardware) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.read_attr_hardware


    # -------------------------------------------------------------------------
    #    SKAEXTRA command methods
    # -------------------------------------------------------------------------
    
    def to_json(self, argin):
        """ Returns a JSON translation of this device as a JSON document.
        :param argin: [{`name`: `with_value`, `type`: `str`}]
        :type argin: PyTango.DevString
        :return: The JSON string representing this device.
        :rtype: PyTango.DevString
        """
        self.debug_stream("In to_json()")
        argout = ""
        #----- PROTECTED REGION ID(SKAEXTRA.to_json) ENABLED START -----#
        with exception_manager(self):
            device_dict = self.get_represention(argin)
            argout = json.dumps(device_dict)

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.to_json
        return argout
        
    def commands_to_json(self, argin):
        """ 
        :param argin: [{`name`: `with_context`, `type`: `bool`, `default:`True`}]
        :type argin: PyTango.DevString
        :rtype: PyTango.DevString
        """
        self.debug_stream("In commands_to_json()")
        argout = ""
        #----- PROTECTED REGION ID(SKAEXTRA.commands_to_json) ENABLED START -----#
        with exception_manager:
            defaults = {'with_context': True}
            args_dict = self.try_parse_argin(argin, defaults=defaults)

            commands = self.get_dp_commands(**args_dict)
            argout = json.dumps(commands)

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.commands_to_json
        return argout
        
    def attributes_to_json(self, argin):
        """ 
        :param argin: 
            [{`name`: `with_value`, `type`: `str`, `default`: `False`},
            {`name`: `with_context`, `type`: `str`, `default`:`True`}]
        :type argin: PyTango.DevString
        :return: The attributes of this device in json
        :rtype: PyTango.DevString
        """
        self.debug_stream("In attributes_to_json()")
        argout = ""
        #----- PROTECTED REGION ID(SKAEXTRA.attributes_to_json) ENABLED START -----#
        with exception_manager(self):
            defaults = {'with_value': False, 'with_context': True}
            args_dict = self.try_parse_argin(argin, defaults=defaults)

            attributes = self.get_dp_attributes(**args_dict)
            argout = json.dumps(attributes)

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.attributes_to_json
        return argout
        
    def get_metrics(self):
        """ gets list of attributes marked as metrics for device
        :rtype: PyTango.DevVarStringArray
        """
        self.debug_stream("In get_metrics()")
        argout = [""]
        #----- PROTECTED REGION ID(SKAEXTRA.get_metrics) ENABLED START -----#
        argout = list(self.metric_set)
        #----- PROTECTED REGION END -----#	//	SKAEXTRA.get_metrics
        return argout
        
    def on_exported_hook(self):
        """ command run by thread when device is exported
        """
        self.debug_stream("In on_exported_hook()")
        #----- PROTECTED REGION ID(SKAEXTRA.on_exported_hook) ENABLED START -----
        #TODO: What is this doing?
        if not self.alarms_set:
            from time import sleep
            if self.get_name() == "test/rack/1":
                sleep(1)
            print "In {} read_alarms_set()".format(self.get_name())
        #----- PROTECTED REGION END -----#	//	SKAEXTRA.on_exported_hook
        
    def reset(self):
        """ Reset device to default state
        """
        self.debug_stream("In reset()")
        #----- PROTECTED REGION ID(SKAEXTRA.reset) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.reset
        
    def InitializeLoggers(self):
        """ Initialize loggers
        """
        self.debug_stream("In InitializeLoggers()")
        #----- PROTECTED REGION ID(SKAEXTRA.InitializeLoggers) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.InitializeLoggers
        
    def InitializeFwdAttrs(self):
        """ Initialize fwd attributes. 
        Fwd attributes are dynamically added at device startup. 
        However when the root device server is down the initialization
        fails. This command is supposed to be run periodically to
        ensure fwd are created if the root device comes online.
        """
        self.debug_stream("In InitializeFwdAttrs()")
        #----- PROTECTED REGION ID(SKAEXTRA.InitializeFwdAttrs) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.InitializeFwdAttrs
        
    def InitializeDevProxies(self):
        """ Initialize device proxies. This command is periodically polled.
        """
        self.debug_stream("In InitializeDevProxies()")
        #----- PROTECTED REGION ID(SKAEXTRA.InitializeDevProxies) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.InitializeDevProxies
        
    def GetRegisteredFormulas(self):
        """ Returns a list of attr formulas currently registered in 
        device and expressed in json format.
        :return: 
            The list of attr formulas currently registered in device 
            and expressed in json format.
        :rtype: PyTango.DevVarStringArray
        """
        self.debug_stream("In GetRegisteredFormulas()")
        argout = [""]
        #----- PROTECTED REGION ID(SKAEXTRA.GetRegisteredFormulas) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.GetRegisteredFormulas
        return argout
        
    def GetInitializedFormulas(self):
        """ 
        :rtype: PyTango.DevVarStringArray
        """
        self.debug_stream("In GetInitializedFormulas()")
        argout = [""]
        #----- PROTECTED REGION ID(SKAEXTRA.GetInitializedFormulas) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.GetInitializedFormulas
        return argout
        
    def UpdateFormulaAttrs(self):
        """ Initialize and update attr formula registered in device. 
        This is needed since device proxies specified in attr formula
        may be offline when the formula is initially registered and 
        initialized. This command is periodically executed to ensure
        that when proxies are online the formula is initialized.
        It is also used to trigger switching of formula attr quality
        factor to INVALID when one/more formula vars are old (e.g.
        proxy down or events not received).
        """
        self.debug_stream("In UpdateFormulaAttrs()")
        #----- PROTECTED REGION ID(SKAEXTRA.UpdateFormulaAttrs) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.UpdateFormulaAttrs
        
    def UpdateStatusAttrs(self):
        """ Update status attribute values from task manager info
        """
        self.debug_stream("In UpdateStatusAttrs()")
        #----- PROTECTED REGION ID(SKAEXTRA.UpdateStatusAttrs) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.UpdateStatusAttrs
        
    def MonitorProxies(self):
        """ Monitor list of registered proxies
        """
        self.debug_stream("In MonitorProxies()")
        #----- PROTECTED REGION ID(SKAEXTRA.MonitorProxies) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.MonitorProxies
        
    def GetFormulaData(self, argin):
        """ Find formula with given arg name and return formula var data
        encoded in json string format.
        :param argin: Formula attr name
        :type argin: PyTango.DevString
        :return: Formula data encoded in json string
        :rtype: PyTango.DevString
        """
        self.debug_stream("In GetFormulaData()")
        argout = ""
        #----- PROTECTED REGION ID(SKAEXTRA.GetFormulaData) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.GetFormulaData
        return argout
        

    #----- PROTECTED REGION ID(SKAEXTRA.programmer_methods) ENABLED START -----#

    def create_local_alarm(self, alarm_dict, polling_time):
        alarm_json = json.dumps(alarm_dict)
        alarm_formulas, attributes, trigger_times, names = FormulaTranslator.translate(
            alarm_json)

        # Start polling and change events for attributes
        for full_attribute_name in attributes:
            attribute = str(full_attribute_name.split("/")[3])  # unicode doesn't agree with tango
            self.poll_attribute(attribute, polling_time)
            config = self.get_attribute_config_3(attribute)[0]
            epsilon = math.ldexp(1.0, -53)  # smallest double that 0.5+epsilon != 0.5
            if config.data_type != 19:
                config.event_prop.ch_event.abs_change = str(epsilon)  # "1"
            self.set_attribute_config_3(config)

        elettra_proxy = DeviceProxy(self.ELETTRA_ALARM_DEVICE_ADDRESS)
        for idx, formula in enumerate(alarm_formulas):
            alarm_name = str(self.get_name()) + "/" + str(names[idx])
            alarm_formula = "(" + formula + ")"
            time_treshold = trigger_times[idx]  # 0 default
            level = "log"
            group = "gr_all"
            message = "\"Alarm occured for condition: " + alarm_formula + "\""
            alarm_handle = self.get_name() + "/" + "alarm_on"
            normal_handle = self.get_name() + "/" + "alarm_off"
            elettra_alarm_string = alarm_name + " " + alarm_formula + " " + time_treshold + " " + \
                                   level + " " + group + " " + message + " " + alarm_handle + ";" + normal_handle
            elettra_proxy.command_inout_asynch("load", elettra_alarm_string)

    def emit_local_event(self, event_msg=None):
        emit_dict = {"event_id": str(self.attr_device_event_counter_read),
                     "message": str(event_msg),
                     "device_state": str(self.dev_state())}

        self.attr_device_event_info_read = json.dumps(emit_dict)
        self.push_event("device_event_info", [], [], self.attr_device_event_info_read)

    def event_stream(self, message):
        emit_dict = {"device_name": self.get_name(),
                     "timestamp": str(datetime.now()),
                     "message": message,
                     "device_state": str(self.dev_state())}

        self.event_proxy.push(json.dumps(emit_dict))

    def get_domain(self):
        """
        Domain is supplied as a command line arg of the Device Server, and is reflected in the device name
        For LMC, all devices must be created within the same domain
        :return: the domain
        """
        return self.domain

    def get_device_metric_list(self):
        list = self.metric_list
        if len(list) <= 0:
            return []
        else:
            return list.split(",")

    def get_device_register_list(self):
        list = self.register_list
        if len(list) <= 0:
            return []
        else:
            return list.split(",")

    def get_device_command_list(self):
        list = self.command_list
        if len(list) <= 0:
            return []
        else:
            return list.split(",")

    def get_elettra_alarm_device_address(self):
        return self.elettra_alarm_device_address

    def get_central_alarmstream_device_address(self):
        return self.central_alarmstream_device_address

    def get_central_eventstream_device_address(self):
        return self.central_eventstream_device_address

    def build_device_name(self, device_type, device_id='*'):
        return '%s/%s/%s' % (self.DOMAIN, device_type, device_id)

    def get_device_group_and_id(self, device_name):
        device_name = device_name
        return device_name.split('/')[1:]

    def _unpickle_cmd_args(self, argin):
        try:
            return json.loads(argin, object_hook=as_enum)
        except (PyTango.DevFailed, Exception) as df:
            return {}

    def _run_proxy_command(self, proxy, cmd_name, **kwargs):
        if kwargs:
            cmd_args = json.dumps(kwargs, cls=EnumEncoder)
            return proxy.command_inout(cmd_name, cmd_args)
        else:
            return proxy.command_inout(cmd_name)

    def _generic_fatal_stream(self, command_name, command_inputs, message):
        # Input can be a pickled string, so check
        if isinstance(command_inputs, str):
            try:
                # was it pickled?
                dict_content = self._unpickle_cmd_args(command_inputs)
                self.fatal_stream("Failure for: [%s], with input: [%s] - Exception: [%s]" % (
                command_name, str(dict_content), message))

            except:
                self.fatal_stream("Failure for: [%s], with input: [%s] - Exception: [%s]" % (
                command_name, command_inputs, message))

    def _generic_alarm_stream(self, proxy, attribute, event):
        self.error_stream("ALARM for: [%s] in attribute: [%s]. Event source: [%s], for value [%s]"
                          % (proxy, attribute, event.event, str(event.attr_value.value)))

    def dp_set_property(self, name, value):
        dp = DeviceProxy(self.get_name())
        db_datum = DbDatum()
        db_datum.name = name
        db_datum.value_string.append(value)
        dp.put_property(db_datum)

    def dp_get_property(self, name):
        dp = DeviceProxy(self.get_name())
        return dp.get_property(name)[name]

    def try_parse_argin(self, argin, defaults=None, required=None):
        args_dict = defaults.copy() if defaults else {}
        try:
            if argin:
                args_dict.update(json.loads(argin))
        except ValueError, ex:
            self.error_stream(ex)
            raise

        missing_args = []
        if required:
            missing_args = set(required) - set(args_dict.keys())
        if missing_args:
            msg = "Missing arguments: %s" % ', '.join([str(m_arg) for m_arg in missing_args])
            raise Exception(msg)
        return args_dict

    def get_dp_commands(self, with_context=True):
        commands = []
        device_proxy = DeviceProxy(self.get_name())
        cmd_config_list = device_proxy.command_list_query()
        for device_cmd_config in cmd_config_list:
            if device_cmd_config.cmd_name in self.public_command_set:
                commands.append(get_dp_command(
                    device_proxy.dev_name(), device_cmd_config, with_context)
                )
        return commands

    def get_dp_attributes(self, with_value=False, with_context=True, attribute_name=None):
        attributes = []
        device_proxy = DeviceProxy(self.get_name())
        if attribute_name:
            attr_config = device_proxy.get_attribute_config_ex(attribute_name)
            attribute_config_list = attr_config
        else:
            attribute_config_list = device_proxy.attribute_list_query_ex()

        for device_attr_config in attribute_config_list:
            attributes.append(get_dp_attribute(
                device_proxy,
                device_attr_config,
                with_value=with_value,
                with_context=with_context
            ))
        for attr in attributes:
            if attr["name"] in self.register_set:
                attr["attribute_type"] = "register"
            elif attr["name"] in self.metric_set:
                attr["attribute_type"] = "metric"
            else:
                attr["attribute_type"] = "attribute"
        return attributes

    def get_represention(self, argin):
        defaults = {'with_value': False}
        args_dict = self.try_parse_argin(argin, defaults=defaults)

        try:

            device_dict = {
                'component_id': self.device_id,
                'component_type': self.device_type,
                'firmware': [],
                'properties': self.get_dp_attributes(
                    with_value=args_dict.get('with_value'),
                    with_context=False
                ),
                'commands': self.get_dp_commands(with_context=False)
            }

            return device_dict
        except Exception, ex:
            self.error_stream(str(ex))
            raise

    def set_alarms(self):
        pass


    #----- PROTECTED REGION END -----#	//	SKAEXTRA.programmer_methods

class SKAEXTRAClass(SKABASEClass):
    # -------- Add you global class variables here --------------------------
    #----- PROTECTED REGION ID(SKAEXTRA.global_class_variables) ENABLED START -----#

    #----- PROTECTED REGION END -----#	//	SKAEXTRA.global_class_variables


    #    Class Properties
    class_property_list = {
        }
    class_property_list.update(SKABASEClass.class_property_list)


    #    Device Properties
    device_property_list = {
        'ConfigFile':
            [PyTango.DevString, 
            "String with full path to a XML file with device configuration\n(attributes & their properties)",
            [] ],
        'EnableConfigFromFile':
            [PyTango.DevBoolean, 
            "Configure device attribute from file",
            [false]],
        'EventSubscriptions':
            [PyTango.DevVarStringArray, 
            "List of event subscriptions to be performed for this device in\nthe following format:\n\n[0]= full attr name 1\n[1]= event type 1\n...\n[N]= full attr name N\n[N+1]= event type N",
            [] ],
        'EventHandlers':
            [PyTango.DevVarStringArray, 
            "List of event handlers to be registered in device given in the following\nformat:\n\n[0]: full attr name\n[1]: event type string\n[2]: name of event handler command\n[3]: execution delay (0=now)\n[4]: priority (0=LOW,1=MEDIUM,2=HIGH)\n...\n[N]: ...\n[N+1]: ...\n[N+2]: ...\n[N+3]: ...\n[N+4]: ...\n\nCommand handler name must exist in device otherwise registration\nfails.",
            [] ],
        'EnableDynAttrCleanup':
            [PyTango.DevBoolean, 
            "Enable/disable automatic cleanup of dynamical attributes created, \ne.g. at device destroy all dynamical attributes created from\nconfig file are removed from the device.",
            [false]],
        'EnableFormulaAttrUpdatePolling':
            [PyTango.DevBoolean, 
            "Enable/disable update of formula attrs present in device.\nThe update is needed to initialize the formula in case one/more \nproxies  contained in the device were down at the startup.\nIf initialization is succesful, the formula attr is evaluated to \nupdate the quality status. If not done, otherwise, the formula attr is\nonly computed when proxy events are received.\n\nYou can turn off this flag if you don`t have formula attrs in your\ndevice.",
            [true]],
        'FormulaAttrUpdatePollPeriod':
            [PyTango.DevLong, 
             '',
            [5000]],
        'FormulaVarMaxTimeInterval':
            [PyTango.DevLong, 
            "Max time interval (in seconds) for an attribute value present in \nattr formula after which \nthe formula is declared as `old` and relative formula \nresult attribute quality switched to INVALID",
            [10]],
        'EnableProxyMonitoring':
            [PyTango.DevBoolean, 
            "Enable periodic monitoring of managed devices\n\nIf enabled, a monitoring thread will be started and\nwhenever a managed device is registered a corresponding \ndyn attr is created in device with notation:\n\nproxyRunStatus_[domain_name]_[family_name]_[member_name]\n\nholding the monitoring status.",
            [false]],
        'ProxyMonitoringPeriod':
            [PyTango.DevLong, 
            "Period (in ms) used to monitor managed devices.",
            [10000]],
        'ProxyStatusAttrPollPeriod':
            [PyTango.DevLong, 
            "Polling period for proxy status attributes in ms",
            [10000]],
        'ProxyStatusAttrPeriodicEventPeriod':
            [PyTango.DevLong, 
            "Periodic event period for proxy status attributes in ms",
            [10000]],
        'ProxyStatusAttrArchiveEventPeriod':
            [PyTango.DevLong, 
            "Archive event period for proxy status attributes in ms",
            [20000]],
        'ProxyTimeout':
            [PyTango.DevLong, 
            "Timeout (in s) after which a non responding proxy device is marked\nas down (in hard state)",
            [20]],
        'EnableDevProxyInitPolling':
            [PyTango.DevBoolean, 
            "Enable/disable polling of proxy initialization & registration. \nThis is to handle down proxy at startup. In this case if the \ninitialization is not re-attempted that proxies will never be \nregistered in device.",
            [true]],
        'DevProxyInitPollPeriod':
            [PyTango.DevLong, 
             '',
            [10000]],
        'EnableLoggerInitPolling':
            [PyTango.DevBoolean, 
            "Enable/disable periodic logging system initialization. \nThis is to allow adding log target devices if they are not present \n(e.g. because down) at device initialization.",
            [true]],
        'LoggerInitPollPeriod':
            [PyTango.DevLong, 
            "Logging initialization polling period in ms.",
            [10000]],
        'EnableFwdAttrInitPolling':
            [PyTango.DevBoolean, 
             '',
            [true]],
        'FwdAttrInitPollPeriod':
            [PyTango.DevLong, 
             '',
            [5000]],
        'EnableStatusAttrUpdatePolling':
            [PyTango.DevBoolean, 
             '',
            [true]],
        'StatusAttrUpdatePollPeriod':
            [PyTango.DevLong, 
             '',
            [3000]],
        'EnableProxyStatusAttrCreation':
            [PyTango.DevBoolean, 
            "Enable proxy status attr creation",
            [false]],
        'EnableAutoAdminProxyRegistration':
            [PyTango.DevBoolean, 
            "Enable/disable automatic registration of admin device whenever\na proxy registration is needed.",
            [false]],
        'Metrics_list':
            [PyTango.DevString, 
            "A list of metrics we want to expose.",
            [] ],
        'SyslogFacility':
            [PyTango.DevString, 
            "LOG_USER: A miscellaneous user process\nLOG_MAIL: Mail\nLOG_DAEMON: A miscellaneous system daemon\nLOG_AUTH:  Security (authorization)\nLOG_SYSLOG: Syslog\nLOG_LPR: Central printer\nLOG_NEWS: Network news (e.g. Usenet)\nLOG_UUCP: UUCP\nLOG_CRON: Cron and At\nLOG_AUTHPRIV: Private security (authorization)\nLOG_FTP: Ftp server\nLOG_LOCAL0,1,2,3,4,5,6,7: Locally defined\n\n``auth``: LOG_AUTH\n``authpriv``: LOG_AUTHPRIV\n``cron``: LOG_CRON \n``daemon``: LOG_DAEMON\n``ftp``: LOG_FTP\n``kern``: LOG_KERN\n``lpr``: LOG_LPR\n``mail``: LOG_MAIL\n``mark``: INTERNAL_MARK\n``news``: LOG_NEWS\n``security``: LOG_AUTH,\n``syslog``: LOG_SYSLOG\n``user``: LOG_USER\n``uucp``: LOG_UUCP\n``local0``: LOG_LOCAL0\n``local1``: LOG_LOCAL1 \n``local2``: LOG_LOCAL2 \n``local3``: LOG_LOCAL3 \n``local4``: LOG_LOCAL4 \n``local5``: LOG_LOCAL5 \n``local6``: LOG_LOCAL6 \n``local7``: LOG_LOCAL7",
            ["local6"] ],
        'SyslogHost':
            [PyTango.DevString, 
            "Hostname of syslog server used for log storage",
            ["localhost"] ],
        }
    device_property_list.update(SKABASEClass.device_property_list)


    #    Command definitions
    cmd_list = {
        'to_json':
            [[PyTango.DevString, "[{`name`: `with_value`, `type`: `str`}]"],
            [PyTango.DevString, "The JSON string representing this device."]],
        'commands_to_json':
            [[PyTango.DevString, "[{`name`: `with_context`, `type`: `bool`, `default:`True`}]"],
            [PyTango.DevString, "none"]],
        'attributes_to_json':
            [[PyTango.DevString, "[{`name`: `with_value`, `type`: `str`, `default`: `False`},\n{`name`: `with_context`, `type`: `str`, `default`:`True`}]"],
            [PyTango.DevString, "The attributes of this device in json"]],
        'get_metrics':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVarStringArray, "none"],
            {
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'on_exported_hook':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'reset':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'InitializeLoggers':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"],
            {
                'Polling period': "10000",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'InitializeFwdAttrs':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"],
            {
                'Polling period': "5000",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'InitializeDevProxies':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"],
            {
                'Polling period': "10000",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'GetRegisteredFormulas':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVarStringArray, "The list of attr formulas currently registered in device \nand expressed in json format."]],
        'GetInitializedFormulas':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVarStringArray, "none"]],
        'UpdateFormulaAttrs':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"],
            {
                'Polling period': "5000",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'UpdateStatusAttrs':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"],
            {
                'Polling period': "3000",
                'Display level': PyTango.DispLevel.EXPERT,
            } ],
        'MonitorProxies':
            [[PyTango.DevVoid, "none"],
            [PyTango.DevVoid, "none"]],
        'GetFormulaData':
            [[PyTango.DevString, "Formula attr name"],
            [PyTango.DevString, "Formula data encoded in json string"]],
        }
    cmd_list.update(SKABASEClass.cmd_list)


    #    Attribute definitions
    attr_list = {
        'centralLoggerStatus':
            [[,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description': "Central logging target status. Possible values are:\n\nUNKNOWN: Typically set at device startup\nDISABLED: When central logging target is disabled (see device properties)\nOK: When central logging target is initialized with success\nFAILED: When central logging target initialization fails, e.g. logger is offline or proxy name invalid ",
                'Polling period': "3000",
                'period': "3000",
            } ],
        'elementLoggerStatus':
            [[,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description': "Element logging target status. Possible values are:\n\nUNKNOWN: Typically set at device startup\nDISABLED: When element logging target is disabled (see device properties)\nOK: When element logging target is initialized with success\nFAILED: When element logging target initialization fails, e.g. logger is offline or proxy name invalid ",
                'Polling period': "3000",
                'period': "3000",
            } ],
        'storageLoggerStatus':
            [[,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description': "Storage logging target status. Possible values are:\n\nUNKNOWN: Typically set at device startup\nDISABLED: When storage logging target is disabled (see device properties)\nOK: When storage logging target is initialized with success\nFAILED: When storage logging target initialization fails, e.g. logger is offline or proxy name invalid ",
                'Polling period': "3000",
                'period': "3000",
            } ],
        'fwdAttrInitStatus':
            [[,
            PyTango.SCALAR,
            PyTango.READ],
            {
                'description': "Initialization status of fwd attributes in device. \n\nUNKNOWN: typically at startup\nOK: All fwd attributes initialized or no fwd attributes present in device\nFAILED: One/more fwd attributes not initialized yet (e.g. root device down)",
                'Polling period': "10000",
                'period': "10000",
            } ],
        }
    attr_list.update(SKABASEClass.attr_list)


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(SKAEXTRAClass, SKAEXTRA, 'SKAEXTRA')
        #----- PROTECTED REGION ID(SKAEXTRA.add_classes) ENABLED START -----#

        #----- PROTECTED REGION END -----#	//	SKAEXTRA.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed as e:
        print ('-------> Received a DevFailed exception:', e)
    except Exception as e:
        print ('-------> An unforeseen exception occured....', e)

if __name__ == '__main__':
    main()
